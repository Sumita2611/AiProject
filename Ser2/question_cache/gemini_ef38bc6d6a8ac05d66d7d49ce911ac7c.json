{"title": "Sort the Candy Jars", "difficulty": "Easy", "description": "You have a list of candy jars, each represented by a tuple containing (jar_id, number_of_candies).  Your task is to sort the jars in ascending order based on the number of candies they contain. If two jars have the same number of candies, they should be sorted in ascending order by their jar ID.", "examples": [{"input": "`[(3, 10), (1, 5), (2, 10), (4, 2)]`", "output": "`[(4, 2), (1, 5), (3, 10), (2, 10)]`", "explanation": "First, we sort by the number of candies (ascending).  Then, for jars with the same number of candies (jars 2 and 3 both have 10), we sort by jar ID (ascending)."}, {"input": "`[(1, 15), (5, 10), (2, 25), (3, 10)]`", "output": "`[(5, 10), (3, 10), (1, 15), (2, 25)]`", "explanation": "Jars with 10 candies are sorted by ID first (5, then 3), then jars with 15 and 25 candies are placed accordingly.\n\n\nConstraints:\n- The input list will contain at least one jar.\n- `jar_id` will be a unique positive integer.\n- `number_of_candies` will be a non-negative integer.\n- Time complexity should be O(n log n), where n is the number of jars.  Space complexity should be O(n) or better (in-place sorting is preferred, but not required)."}], "constraints": ["- The input list will contain at least one jar.", "- `jar_id` will be a unique positive integer.", "- `number_of_candies` will be a non-negative integer.", "- Time complexity should be O(n log n), where n is the number of jars.  Space complexity should be O(n) or better (in-place sorting is preferred, but not required)."], "function_signature": {"java": "public List<Tuple<Integer, Integer>> sortCandyJars(List<Tuple<Integer, Integer>> jars) { // Your code here }", "cpp": "std::vector<std::pair<int, int>> sortCandyJars(std::vector<std::pair<int, int>>& jars) { // Your code here }", "python": "def sort_candy_jars(jars): # Your code here\n    pass"}, "id": "ef38bc6d6a8ac05d66d7d49ce911ac7c", "category": "sorting"}