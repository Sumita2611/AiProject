{"title": "Colorful Block Arrangement", "difficulty": "Easy", "description": "You have a set of colored blocks. Each block has a color represented by a single character (e.g., 'R' for red, 'G' for green, 'B' for blue). You want to arrange these blocks in a row such that no two adjacent blocks have the same color.  Write a function that finds all possible valid arrangements of the blocks.  The function should return a list of strings, where each string represents a valid arrangement.", "examples": [{"input": "['R', 'G', 'B']", "output": "['RGB', 'RBG', 'GRB', 'GBR', 'BRG', 'BGR']", "explanation": "All possible arrangements where no two adjacent blocks have the same color are listed."}, {"input": "['R', 'R', 'G']", "output": "['RGR', 'GRR']", "explanation": "Only arrangements where no adjacent blocks are the same color are included.  'RRG' and 'RGR' are invalid.\n\n\nConstraints:\n- The input list will contain only uppercase letters representing colors.\n- The length of the input list will be between 1 and 6 (inclusive).\n- Time and space complexity are not strictly constrained for this easy level problem, but efficient solutions are preferred."}], "constraints": ["- The input list will contain only uppercase letters representing colors.", "- The length of the input list will be between 1 and 6 (inclusive).", "- Time and space complexity are not strictly constrained for this easy level problem, but efficient solutions are preferred."], "function_signature": {"java": "public List<String> arrangeBlocks(char[] blocks) { // Your code here }", "cpp": "std::vector<std::string> arrangeBlocks(std::vector<char> blocks) { // Your code here }", "python": "def arrange_blocks(blocks): # Your code here\n    pass"}, "id": "fdc2af3d64a38f54de6fcba9b491f291", "category": "backtracking"}